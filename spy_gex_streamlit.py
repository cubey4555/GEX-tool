# -*- coding: utf-8 -*-
"""Copy of  Final Final Main GEX graph no download.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fyexIG_Y9-paoPUXUtXLvldkjHoGmfcf
"""

# spy_gex_streamlit.py
import yfinance as yf
import pandas as pd
import numpy as np
from scipy.stats import norm
import plotly.graph_objects as go
import streamlit as st


st.set_page_config(page_title="SPX/SPY GEX Dashboard", layout="wide")
st.title("📊 SPX/SPY GEX Dashboard (Interactive)")

# --- User inputs ---
symbol = st.text_input("Enter ticker symbol (e.g., SPY, TSLA):", value="SPY").upper()
range_strikes = st.slider("Number of strikes above/below spot to include:", 1, 50, 10)

# Fetch available expirations
ticker = yf.Ticker(symbol)
try:
    expirations = ticker.options
except:
    st.error("Error fetching options expirations. Check symbol.")
    st.stop()

if not expirations:
    st.warning("No options data available for this symbol.")
    st.stop()

st.write("Available expirations:", expirations)
expiry_choice = st.selectbox("Choose expiry (first one is default):", expirations, index=0)

# --- Fetch options for chosen expiry ---
def get_options(symbol, expiry):
    ticker = yf.Ticker(symbol)
    chain = ticker.option_chain(expiry)
    return chain.calls, chain.puts

calls, puts = get_options(symbol, expiry_choice)
calls['expiry'] = expiry_choice
puts['expiry'] = expiry_choice

# Combine into single DataFrame
def preprocess_options(df_calls, df_puts):
    df_calls.columns = [c.lower().strip() for c in df_calls.columns]
    df_puts.columns = [c.lower().strip() for c in df_puts.columns]

    df_calls = df_calls.rename(columns={
        "openinterest":"oi_call",
        "volume":"vol_call",
        "impliedvolatility":"iv_call"
    })
    df_puts = df_puts.rename(columns={
        "openinterest":"oi_put",
        "volume":"vol_put",
        "impliedvolatility":"iv_put"
    })

    df_calls = df_calls[["strike","oi_call","vol_call","iv_call","lasttradedate"]]
    df_puts  = df_puts [["strike","oi_put","vol_put","iv_put","lasttradedate"]]

    df = pd.merge(df_calls, df_puts, on="strike", suffixes=("_call","_put"))

    for col in ["strike","iv_call","oi_call","iv_put","oi_put"]:
        df[col] = pd.to_numeric(df[col], errors="coerce").fillna(0)

    def fix_iv(iv):
        if iv > 1:
            return iv / 100
        return iv  # Keep the original if already a decimal

    df["iv_call"] = df["iv_call"].apply(fix_iv)
    df["iv_put"]  = df["iv_put"].apply(fix_iv)

    return df

df = preprocess_options(calls, puts)

# Auto-spot
spot = ticker.history(period="1d")["Close"].iloc[-1]

# Filter by strikes around spot
df = df[(df["strike"] >= spot - range_strikes) & (df["strike"] <= spot + range_strikes)]

st.write(f"Spot detected: {spot:.2f}, using ±{range_strikes} strikes")
st.dataframe(df.head(20))

# --- Calculate GEX ---
r = 0.05
T = 1/252

def bs_gamma(S,K,T,r,sigma):
    if T <= 0 or sigma <= 0:
        return 0
    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T)/(sigma*np.sqrt(T))
    return norm.pdf(d1)/(S*sigma*np.sqrt(T))

df["gamma_call"] = df.apply(lambda row: bs_gamma(spot, row["strike"], T, r, row["iv_call"]), axis=1)
df["gamma_put"]  = df.apply(lambda row: bs_gamma(spot, row["strike"], T, r, row["iv_put"]), axis=1)

df["call_gex"] = df["gamma_call"] * df["oi_call"] * 100 * spot
df["put_gex"]  = -df["gamma_put"] * df["oi_put"] * 100 * spot

df_total = df.groupby("strike").agg({
    "call_gex":"sum",
    "put_gex":"sum",
    "oi_call":"sum",
    "oi_put":"sum"
}).reset_index()

df_total["net_gex"] = df_total["call_gex"] + df_total["put_gex"]
df_total["abs_gex"] = df_total["call_gex"].abs() + df_total["put_gex"].abs()
df_total["total_oi"] = df_total["oi_call"] + df_total["oi_put"]

total_gamma_abs = df_total["abs_gex"].sum()
total_net_gamma = df_total["net_gex"].sum()

# --- Power Zone ---
abs_gex_sum = df_total["abs_gex"].sum()
oi_sum = df_total["total_oi"].sum()
alpha = 0.25
weights = df_total["abs_gex"] + alpha * df_total["total_oi"]
weights = weights if weights.sum() !=0 else pd.Series(1.0, index=df_total.index)

power_center = (df_total["strike"] * weights).sum() / weights.sum()
var = ((weights * (df_total["strike"] - power_center)**2).sum()) / weights.sum()
power_std = np.sqrt(var)
k = 1.0
power_lower = power_center - k * power_std
power_upper = power_center + k * power_std
inside_mask = (df_total["strike"] >= power_lower) & (df_total["strike"] <= power_upper)
power_score = weights[inside_mask].sum() / weights.sum()

# --- Directional bias & predicted close ---
num_green = (df_total["net_gex"] > 0).sum()
num_red   = (df_total["net_gex"] < 0).sum()
if num_green > num_red:
    direction_bias = "Slightly Bullish"
elif num_red > num_green:
    direction_bias = "Slightly Bearish"
else:
    direction_bias = "Neutral / Mixed"

# Predicted close (simplified weighted)
predicted_close = np.average(df_total["strike"], weights=df_total["abs_gex"]) if not df_total.empty else None

# --- Plotly chart ---
colors = ["green" if val>=0 else "red" for val in df_total["net_gex"]]
fig = go.Figure()
fig.add_trace(go.Bar(x=df_total["strike"], y=df_total["net_gex"], name="Net GEX", marker_color=colors))
fig.add_trace(go.Scatter(x=df_total["strike"], y=df_total["abs_gex"], mode="lines+markers", name="Abs GEX", line=dict(color="purple", width=2)))
fig.add_vline(x=spot, line=dict(color="yellow", width=2, dash="dash"), annotation_text="Spot", annotation_position="top")
fig.add_vrect(x0=power_lower, x1=power_upper, fillcolor="purple", opacity=0.15, layer="below", line_width=0)
fig.add_vline(x=power_center, line=dict(color="magenta", width=2, dash="dashdot"), annotation_text="Power Zone", annotation_position="top")
fig.update_layout(title=f"{symbol} GEX Dashboard", xaxis_title="Strike Price", yaxis_title="GEX / OI", paper_bgcolor="black", plot_bgcolor="black", font=dict(color="white"))
st.plotly_chart(fig, use_container_width=True)

# --- Summary metrics ---
st.subheader("Summary Metrics")
st.write(f"Total Abs Gamma: {total_gamma_abs:,.0f}")
st.write(f"Total Net Gamma: {total_net_gamma:,.0f}")
st.write(f"Power Zone Center: {power_center:.2f}")
st.write(f"Power Zone Band: [{power_lower:.2f}, {power_upper:.2f}]")
st.write(f"Power Score: {power_score:.2%}")
st.write(f"Directional Bias: {direction_bias}")
st.write(f"Predicted Close: {predicted_close:.2f}")

# --- Imports for snapshots ---
import os
import datetime

# --- Snapshot folder ---
SNAPSHOT_DIR = "snapshots"
os.makedirs(SNAPSHOT_DIR, exist_ok=True)  # create folder if it doesn't exist

# --- Save snapshot every 30 minutes ---
now = datetime.datetime.now()
minute_slot = (now.minute // 30) * 30  # rounds down to nearest 30-min mark
snapshot_time = now.replace(minute=minute_slot, second=0, microsecond=0)

# Include date in filename (so each day is separate)
snapshot_filename = f"{symbol}_{snapshot_time.strftime('%Y%m%d%H%M')}.csv"
snapshot_path = os.path.join(SNAPSHOT_DIR, snapshot_filename)

# Save CSV only if it doesn't already exist
if not os.path.exists(snapshot_path):
    df_total.to_csv(snapshot_path, index=False)

# --- Display historical snapshots ---
st.subheader("📁 Historical GEX Snapshots")
snapshot_files = sorted(os.listdir(SNAPSHOT_DIR))  # list all files

for file in snapshot_files:
    file_path = os.path.join(SNAPSHOT_DIR, file)
    
    if not file.endswith(".csv"):
        continue  # skip non-csv files
    
    # Parse display time safely
    try:
        time_str = file.split("_")[1].replace(".csv","")
        display_time = datetime.datetime.strptime(time_str, "%Y%m%d%H%M")
        display_time_str = display_time.strftime("%b %d, %I:%M %p")
    except:
        display_time_str = file  # fallback to filename if parsing fails

    # Load the snapshot CSV
    df_snapshot = pd.read_csv(file_path)
    
    # Build the Plotly chart for this snapshot
    fig_snap = go.Figure()
    
    colors = ["green" if val >= 0 else "red" for val in df_snapshot["net_gex"]]
    fig_snap.add_trace(go.Bar(
        x=df_snapshot["strike"],
        y=df_snapshot["net_gex"],
        marker_color=colors
    ))
    
    fig_snap.add_trace(go.Scatter(
        x=df_snapshot["strike"],
        y=df_snapshot["abs_gex"],
        mode="lines+markers",
        line=dict(color="purple", width=2)
    ))
    
    fig_snap.update_layout(
        title=f"GEX Snapshot: {display_time_str}",
        xaxis_title="Strike Price",
        yaxis_title="GEX / OI",
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white")
    )
    
    # Display snapshot in Streamlit
    st.plotly_chart(fig_snap, use_container_width=True)

